---
title: "分布式文件存储技术选型及分析"
date: 2021-11-23T09:12:57+08:00
draft: true
---

## 1 背景

​	公司内部统一存储的所需要的空间越来越大，维护成功越来越高，而分布式存储通过廉价的服务器来提供使用与大规模，高并发场景下的 Web 访问问题。它利用多台存储服务器分担存储负荷，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。

## 2 传统文件存储的问题

- 伸缩性，单机文件系统容量有限，存储规模不够的时候需要扩展。
- 性能瓶颈，单机文件系统通常在文件数目达到临界点后，性能快速下降。读写性能也受传统硬盘的限制。
- 可靠性， 单机文件系统不具备业务的持久性要求。所以通常会使用raid来做数据冗余。而raid在数据量很大的时候，修复时间会很长。
- 可用性，单机文件系统通常只是单副本的方案，在该机器宕机后，数据就不可读取，也不可写入。

## 3  对象存储

在我们公司的存储空间中大多是图片，音视频，Office文档等多媒体文件，是比较典型的非结构化数据。非结构化数据的存储方式，现在业界基本都是使用对象存储的方式。对象存储本质还是键值存储（KV Storage），对象存储的 Key其实就是文件的存储路径，这是对象存储在模拟文件系统中大家的习惯。它拥有，低成本，高可靠，易扩展等优势。

## 4 对象存储概念

对象存储非常简单，只有2个核心概念：存储桶(Bucket)和对象(Object)。一个存储桶可以有很多个对象，这些对象都是平级的，也就是扁平的。在对象存储的时候，KEY就是对象的名称，Value就是对象的内容。所以对于对于是一个类似Hash，是一个KV方式存储。

### 4.1 如何管理对象

既然我们的对象都是扁平存储的，而且还被分片了，那么是如何管理它们的，或者说如何找到我们想要的文件以及文件的信息等？这就是对象存储核心的对象元数据管理。

对象的元数据就是用来管理数据的存储、分片以及数据本身的信息，因为元数据单独存储，所以我们可以为一个对象扩展任意多的元数据，这也是文件存储做不到的。

### 4.2 如何有目录结构

对象存储的底层设计都是扁平的，没有层次结构，但是我们看到的对象存储管理工具的确给我们提供了目录层次的管理，就像我们在使用文件系统一样，其实这样方式是通过KEY进行区分的。

假设我们想达到`/static/1.jpg`这样的存储效果，那么在存储的时候，对于图片`1.jpg`保存在对象存储中的KEY是`/static/1.jpg`,通过KEY中的`/`分隔，达到多级目录的效果，其实本质是KEY做了改变。

### 4.3 如何防止数据丢失

以MinIO为例，对于分布式的对象存储系统，是采用纠删码的方式保证数据的安全。纠删码会把分布式的盘组成一个纠删码集合，默认情况下，哪怕丢失N/2的数据盘，数据也可以正常恢复使用。

假设一个8块盘（可以分散在多个主机上）组成的纠删码集合，哪怕同时又4个盘损坏丢失，数据也可以正常使用，并且可以从中恢复。

## 5  技术选型与对比

​	现在一般数据存储量不大的中小型企业都会选择oss云存储方案，避免本地运维，并且可以无缝对接云供应商的cdn分发，多媒体处理等服务

​	也有一些企业考虑到数据安全性，及随着数据量的增长，会选择当前的一些开源方案，这些存储方案里面可以分为两种：一种是可以自定义对象名称的；另外一种是系统自动生成对象名称，但我们公司的文件名字需要保持不变，所以这种不行。像 FS 就是国内大佬开源的一个分支存储，但是因为不能自定义文件名所以不合适，左划掉。还有像领英的 Ambry、MogileFS 其实都不能自定对象名的，所以是不合适的。左上角 LeoFS 对我们来说不是很可控，所以不合适。TFS 是淘宝开源的，但是目前已经很少有人维护它并且也不是很活跃，所以当时就没有考虑。ceph 是一个比较强大的分布式存储，但是它整个系统非常复杂需要大量的人力进行维护，对我们的产品不是很符合，所以暂时不考虑。

| 存储系统     | Ceph         | Swift      | HDFS     | FastDFS  | Ambry      | MinIO      |
| ------------ | ------------ | ---------- | -------- | -------- | ---------- | ---------- |
| **开发语言** | C++          | Python     | Java     | C        | Java       | Go         |
| **开源协议** | LGPL         | Apache     | Apache   | GPL3     | Apache     | Apache     |
| **存储方式** | 对象/文件/块 | 对象       | 文件     | 文件/块  | 对象       | 对象       |
| **在线扩容** | 支持         | 支持       | 支持     | 支持     | 支持       | 不支持     |
| **冗余备份** | 支持         | 支持       | 支持     | 支持     | 支持       | 支持       |
| **单点故障** | 不存在       | 不存在     | 存在     | 不存在   | 不存在     | 不存在     |
| **易用性**   | 一般         | 一般       | 一般     | 简单     | 简单       | 简单       |
| **跨集群**   | 不支持       | -          | 不支持   | 部分支持 | 不支持     | 支持       |
| **适用场景** | 大中小文件   | 大中小文件 | 大中文件 | 中小文件 | 大中小文件 | 大中小文件 |

## 6  MinIO 和其他OSS存储解决方案各有什么优缺点？

这里主要针对HDFS、Ceph、Minio、FastDFS 热门的存储解决方案进行比较。

### Ceph

**优点**

- 红帽继子，ceph创始人已经加入红帽
- 国内有所谓的ceph中国社区，私人机构，不活跃，文档有滞后，而且没有更新的迹象。
- 从git上提交者来看，中国有几家公司的程序员在提交代码，星辰天合，easystack, 腾讯、阿里基于ceph在做云存储，但是在开源社区中不活跃，阿里一位叫liupan的有参与
- 功能强大 支持数千节点
- 支持动态增加节点，自动平衡数据分布。（TODO，需要多长时间，add node时是否可以不间断运行）
- 可配置性强，可针对不同场景进行调优

**缺点**

- 学习成本高，安装运维复杂。

HDFS

**优点**

- 对大文件的存储性能比较高

- 适合低写入，多次读取的业务

**缺点**

- 单节点，扩展性不好
- 冗余率高

### FastDFS

fastdfs是阿里余庆做的一个个人项目，在一些互联网创业公司中有应用，没有官网，不活跃，6个contributors。

### Minio

**优点**

- 学习成本低，安装运维简单，开箱即用
- 文档非常详细、具体，minio论坛推广给力，有问必答。
- 拥有大多热门语言的SDK，很方便
- 数据保护：分布式Minio采用 纠删码来防范多个节点宕机和位衰减bit rot。分布式Minio至少需要4个硬盘，使用分布式Minio自动引入了纠删码功能。
- 一致性：Minio在分布式和单机模式下，所有读写操作都严格遵守read-after-write一致性模型。

**缺点**

- 不支持动态增加节点，minio创始人的设计理念就是动态增加节点太复杂，可以采用其它方案来支持扩容。

## 7 minio介绍

### 7.1 MINIO 架构

![image-20211123111221615](https://raw.githubusercontent.com/jeffmingup/image/master/img/202111231112746.png)

左边是 MINIO 集群的示意图，整个集群是由多个角色完全相同的节点所组成的。因为没有特殊的节点，所以任何节点宕机都不会影响整个集群节点之间的通信。通过 rest 跟 RPC 去通信的，主要是实现分布式的锁跟文件的一些操作。

右边这张图是单个节点的示意图，每个节点都单独对外提供兼容 S3 的服务。

###  7.2 MINIO 具体概念

![image-20211123111700076](https://raw.githubusercontent.com/jeffmingup/image/master/img/202111231117229.png)

这块有几个概念比较重要，我们来看右边 MINIO 集群存储示意图，每一行是一个节点机器，这有 32 个节点，每个节点里有一个小方块我们称之 Drive，Drive 可以简单地理解为一个硬盘。一个节点有 32 个 Drive，相当于 32 块硬盘。Set 是另外一个概念，Set 是一组 Drive 的集合，所有红色标识的就组成了一个 Set，这两个概念是 MINIO 里面最重要的两个概念，一个对象最终是存储在 Set 上面的。

MINIO 是通过数据编码，将原来的数据编码成 N 份，N 就是一个 Set 上面 Drive 的数量，后面多次提到的 N 都是指这个意思。然后编码把数据写到对应的 Drive 上面，这就是把一个对象存储在整个 Set 上。一个集群包含多个 Set，每个对象最终存储在哪个 Set 上是根据对象的名称进行哈希，然后影射到唯一的 Set 上面，这个方式从理论上保证数据可以均匀的分布到所有的 Set 上。根据我们的观测，数据分布的也非常均匀，一个 Set 上包含多少个 Drive 是由系统自动根据集群规模算出来的，当然你可以自己去配置。一个 Set 的 Drive 系统会考虑尽可能把它放在多的节点上面，保证它的可靠性

### 7.3  纠删码

![image-20211123112637229](https://raw.githubusercontent.com/jeffmingup/image/master/img/202111231126305.png)

MinIO 使用纠删码和校验和保护数据免受硬件故障和静默数据损坏。使用最高级别的冗余，在可能会丢失多达一半 (N/2) 的总驱动器，但仍然能够恢复数据。

纠删码是一种重建丢失或损坏数据的数学算法。MinIO 使用 Reed-Solomon 代码将对象分片为可变数据和奇偶校验块。例如，在一个 12 个驱动器的设置中，一个对象可以被分片到所有驱动器中可变数量的数据和奇偶校验块 - 从六个数据和六个奇偶校验块到十个数据和两个奇偶校验块。

默认情况下，MinIO 跨 N/2 个数据和 N/2 个奇偶校验驱动器对对象进行分片。不过，可以使用[存储类](https://github.com/minio/minio/tree/master/docs/erasure/storage-class)来使用自定义配置。我们推荐 N/2 数据块和奇偶校验块，因为它可以确保对驱动器故障提供最佳保护。

在上面的 12 个驱动器示例中，MinIO 服务器在默认配置下运行，可以丢失 6 个驱动器中的任何一个，但仍然可以从其余驱动器可靠地重建数据。

纠删码的工作原理和RAID或者复制不同，像RAID6可以在损失两块盘的情况下不丢数据，而Minio纠删码可以在丢失一半的盘的情况下，仍可以保证数据安全。 而且Minio纠删码是作用在对象级别，可以一次恢复一个对象，而RAID是作用在卷级别，数据恢复时间很长。 Minio对每个对象单独编码，存储服务一经部署，通常情况下是不需要更换硬盘或者修复。Minio纠删码的设计目标是为了性能和尽可能的使用硬件加速。

### 7.5 位衰减bit rot保护

Bit Rot ，直译过来就是比特腐烂，它是指在物理设备上的一些文件细微的损坏，没有被操作系统或硬件所察觉，但是他已经被损坏了，这是一个严重的问题。所以 Minio 把之前的编码块进行一 HighwayHash 的编码，最后要校验这个编码，以确保每个编码是正确的。基于这两个特性，Minio 的数据可靠性做的很高，另外 Minio 提供了一个管理工具，可以对所有的编码块进行校验，如果发现编码块有问题的话，再去修复它。

## 8 已经验证的应用场景

现在开发环境部署4台minio节点，1台nginx做负载均衡。

- 任意一个节点挂掉，不影响文件上传，读取。
- 任意挂掉两个节点，无法上传新文件，读取文件会有速率限制，但也能正常访问。
- 任意删除一个节点上的某个文件，不会影响该文件的正常访问。删除的文件会被minio自动恢复。

初步验证符合纠删码的特征：可以在丢失一半的盘的情况下，仍可以保证数据安全。

## 9 尚未验证的问题

minio不支持动态扩容，建议初步搭建保证两年内的容量要求，官网也已经提供**对等扩容**，**联邦扩容**等扩容方式。

## 10 会需要的风险

为确保能满足公司业务发展的需要，我们应该根据现有的文件大致分类，及现有服务的吞吐量要求，搭建测试环境，进行性能验证。

新老存储架构的切换问题，会影响的业务模块调整测试。



参考文档

[基于 Go 开源项目 MIMIO 的对象存储方案在探探的实践](https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&mid=2247487119&idx=1&sn=6e09abb32392e015911be3a1d7f066e5&source=41#wechat_redirect)

[Minio纠删码快速入门](http://docs.minio.org.cn/docs/master/minio-erasure-code-quickstart-guide)

