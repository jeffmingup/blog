---
title: "分布式锁理解及etcd实现方案"
date: 2021-09-17T15:56:49+08:00
draft: true
---
## 分布式锁基础

分布式锁，是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。

### 分布式锁应该具备一下特点：

- 互斥性：任意时刻，同一个锁，只有一个进程能持有
- 安全性：避免死锁，当进程没有主动释放锁（进程崩溃退出），保证其他进程能够加锁
- 可用性：当提供锁的服务节点故障（宕机）时，热备节点能够接替故障的节点继续提供服务，并保证自身持有的数据与故障节点一致
- 对称性：对同一个锁，加锁和解锁必须是同一个进程，即某进程不能把其他进程持有的锁给释放了

### <!--互斥性-->

<!--这个没啥好说的，要满足这个特性，一般是多进程共同使用同一个分布式锁服务来管理。-->

### <!--安全性-->

<!--要满足进程崩溃之后，不会出现死锁，就需要给锁加上过期时间。进程崩溃了，锁过期依然会释放。如果出现进程还没处理完，锁就过期了也不行，所以需要守护进程来定时续约过期时间。-->

### <!--可用性-->

<!--这个需要锁服务本身是高可用，像redis主从，etcd（本身就是高可用）-->

### <!--对称性-->

<!--redis处理这个问题的方案是给key分配一个唯一值value，解锁的时候通过lua脚本来判断是不是自己的锁（自己设置的key-value）。-->

<!--etcd是根据key前缀的方式，具体方案看下方，也不会出现这个问题-->

## Redis分布式锁

### SET命令

- EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。

- PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。

- NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。

- XX ： 只在键已经存在时， 才对键进行设置操作。

### 实现流程

redis实现加锁的大致流程就是，使用NX参数多个进程设置同一个key，谁设置成功谁获得锁。

安全性靠过期时间来解决，为了加锁操作的原子性，需要使用set 命令同时加上NX和 EX（过期时间）参数。如果出现进程还没处理完，锁就过期了也不行，所以需要守护进程来定时续约过期时间。

对称性的话，每个进程为key设置一个value(唯一值)。解锁的时候通过lua脚本，先get出value和当前进程做对比，确认一致后才解锁。

### redis分布式锁的问题

其实就是可用性和一致性问题，redis基于内存通常用作缓存服务器，读写性能很高。但是redis的高可用不能保证完全一致性。

比如当前进程刚设置一个锁（set命令），这条set命令还没有同步到redis从服务器上，然后redis主服务器挂了。在redis从服务器升级为主服务器的之后没有这条set命令。就会有别的进程重复获得锁，这样就有问题了。

网上似乎也有一些方案，但是redis本身的一致性并不是它的强项，读写性能高才是。所以类似etcd这种本身就是分布式并具备一致性的服务就成了分布式锁的最佳方案。

## Etcd 特性

这些年，随着 [Raft 协议](https://raft.github.io/) 的广泛应用，涌现出很多的基于此协议实现的高可用分布式系统，比较知名的有 [Etcd](https://github.com/etcd-io/etcd)、[Consul](https://github.com/hashicorp/consul) 等，由于其内部实现了 [分布式一致性](https://zh.wikipedia.org/wiki/CAP定理)，所以非常适合做分布式锁。本片文章就以 Etcd 为例，来介绍下构建分布式锁的方法。值得注意的是，Etcd 分布式锁的实现是在客户端做的。

Etcd 支持以下功能，正是依赖这些功能来实现分布式锁的：

- Lease 机制：即租约机制（TTL，Time To Live），Etcd 可以为存储的 Key-Value 对设置租约，当租约到期，Key-Value 将失效删除；同时也支持续约续期（KeepAlive）
- Revision 机制:  Etcd有个全局的Revision值，Etcd 每进行一次事务对应的全局 Revision 值都会加一 。每个 key 带有一个 CreateRevision属性值就是创建key的时候的全局Revision值，还有对应的ModRevision(修改时候的全局Revision值 )。因此每个 Key 对应的 CreateRevision（ModRevision）属性值都是全局唯一的。(还有一个Version对应当前key的共修改了几次，put相同的值也算修改)。通过比较 CreateRevision的大小就可以知道进行写操作的顺序。在实现分布式锁时，多个程序同时抢锁，根据 CreateRevision值大小依次获得锁，可以避免惊群效应，实现公平锁。
- Prefix 机制：即前缀机制（或目录机制）。可以根据前缀（目录）获取该目录下所有的 Key 及对应的属性（包括 Key、Value 以及 Revision 等）
- Watch 机制：即监听机制，Watch 机制支持 Watch 某个固定的 Key，也支持 Watch 一个目录前缀（前缀机制），当被 Watch 的 Key 或目录发生变化，客户端将收到通知

## Etcd分布式锁，官方Concurrency 包分析

